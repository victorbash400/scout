
## Strands Agents SDK Agent Class Overview

The **Strands Agents SDK** is an open-source framework developed by AWS that takes a model-driven approach to building AI agents. The `Agent` class is the core interface for interacting with foundation models and tools.[1][2]

### Agent Class Initialization (`__init__` method)

Based on the documentation and available source code, the `Agent` class `__init__` method has the following signature:[3]

```python
def __init__(
    self,
    model: Union[Model, str, None] = None,
    messages: Optional[Messages] = None,
    tools: Optional[list[Union[str, dict[str, str], Any]]] = None,
    system_prompt: Optional[str] = None,
    callback_handler: Optional[Union[Callable[..., Any], _DefaultCallbackHandlerSentinel]] = _DEFAULT_CALLBACK_HANDLER,
    conversation_manager: Optional[ConversationManager] = None,
    record_direct_tool_call: bool = True,
    load_tools_from_directory: bool = False,
    trace_attributes: Optional[Mapping[str, AttributeValue]] = None,
    *,
    agent_id: Optional[str] = None,
    name: Optional[str] = None,
    description: Optional[str] = None,
    state: Optional[Union[AgentState, dict]] = None,
    hooks: Optional[list[HookProvider]] = None,
    session_manager: Optional[SessionManager] = None,
    tool_executor: Optional[ToolExecutor] = None,
):
```

**Key Parameters:**
- **model**: Provider for running inference (defaults to BedrockModel if None)
- **messages**: Initial conversation messages
- **tools**: List of tools available to the agent
- **system_prompt**: System prompt to guide behavior
- **callback_handler**: Callback for processing events during execution
- **hooks**: Hook providers for extending functionality
- **session_manager**: Manager for session persistence
- **tool_executor**: Strategy for tool execution (sequential, concurrent, etc.)

### Agent Class `stream_async` Method

The `stream_async` method provides asynchronous streaming of agent events:[4][3]

```python
async def stream_async(
    self,
    prompt: AgentInput = None,
    **kwargs: Any,
) -> AsyncIterator[Any]:
    """Process a natural language prompt and yield events as an async iterator.
    
    Args:
        prompt: User input in various formats:
            - str: Simple text input
            - list[ContentBlock]: Multi-modal content blocks
            - list[Message]: Complete messages with roles
            - None: Use existing conversation history
        **kwargs: Additional parameters to pass to the event loop.
    
    Yields:
        An async iterator that yields events. Each event is a dictionary containing
        information about the current state of processing, such as:
        - data: Text content being generated
        - complete: Whether this is the final chunk
        - current_tool_use: Information about tools being executed
        - And other event data provided by the callback handler
    """
```

### Hook System and Callbacks

Strands uses a **typed hook system** that replaces the older callback_handler approach. The hook system provides composable, type-safe event handling:[5]

#### Base Hook Classes

**HookEvent** - Base class for all hook events:[5]
```python
@dataclass
class HookEvent:
    """Base class for all hook events."""
    agent: Agent  # The agent instance that triggered this event
    
    @property
    def should_reverse_callbacks(self) -> bool:
        """Determine if callbacks should be invoked in reverse order."""
        return False
```

**HookProvider** - Protocol for objects providing hook callbacks:[5]
```python
class HookProvider(Protocol):
    """Protocol for objects that provide hook callbacks to an agent."""
    
    def register_hooks(self, registry: HookRegistry, **kwargs: Any) -> None:
        """Register callback functions for specific event types."""
        pass
```

**HookRegistry** - Manages hook callbacks and event dispatching:[5]
```python
class HookRegistry:
    """Registry for managing hook callbacks associated with event types."""
    
    def add_callback(self, event_type: Type[TEvent], callback: HookCallback[TEvent]) -> None:
        """Register a callback function for a specific event type."""
        
    def add_hook(self, hook: HookProvider) -> None:
        """Register all callbacks from a hook provider."""
        
    def invoke_callbacks(self, event: TInvokeEvent) -> TInvokeEvent:
        """Invoke all registered callbacks for the given event."""
```

#### Available Hook Events

The framework provides several built-in events:[5]

1. **AgentInitializedEvent** - Fired after agent initialization
2. **BeforeInvocationEvent** - Fired before processing a request
3. **AfterInvocationEvent** - Fired after completing a request (reverse order)
4. **MessageAddedEvent** - Fired when messages are added to conversation

### Example Usage

#### Basic Agent with Hooks
```python
from strands import Agent
from strands.hooks import HookProvider, HookRegistry
from strands.hooks.events import BeforeInvocationEvent, AfterInvocationEvent

class LoggingHooks(HookProvider):
    def register_hooks(self, registry: HookRegistry) -> None:
        registry.add_callback(BeforeInvocationEvent, self.log_start)
        registry.add_callback(AfterInvocationEvent, self.log_end)
    
    def log_start(self, event: BeforeInvocationEvent) -> None:
        print(f"Request started for {event.agent.name}")
    
    def log_end(self, event: AfterInvocationEvent) -> None:
        print(f"Request completed for {event.agent.name}")

# Create agent with hooks
agent = Agent(hooks=[LoggingHooks()])
```

#### Streaming with FastAPI
```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
from strands import Agent
from strands_tools import calculator

app = FastAPI()

@app.post("/stream")
async def stream_response(prompt: str):
    async def generate():
        agent = Agent(tools=[calculator])
        async for event in agent.stream_async(prompt):
            if "data" in event:
                yield event["data"]
    
    return StreamingResponse(generate(), media_type="text/plain")
```

### Streaming Nested Tool Calls

Regarding streaming events from nested tool calls, the current implementation has some limitations. The framework can stream tool execution events, but there are known issues with:[6]

1. **Tool result streaming**: If tools don't return data in the expected format with a `callback_handler` key, the events may be "swallowed"[6]
2. **Graph agents**: Streaming support for multi-agent graphs is a requested feature but not yet fully implemented[7][8]
3. **Nested tool execution**: The framework can capture tool events through hooks, but deep nesting scenarios may require custom implementation

### Current Limitations and Future Features

Several features are in development or requested:[9][10][7]

- **Hook support for Graph agents**: Currently callbacks/hooks are not supported in Graph multi-agent mode
- **Enhanced streaming for nested tools**: Better support for streaming from deeply nested tool executions
- **Tool consent in async frameworks**: API for hooking back into tool registry for consent during streaming

The Strands SDK continues to evolve rapidly, with active development on streaming capabilities, hook systems, and multi-agent orchestration features.[11][12][1]
